---
title: "Question 3"
author: "Maharaj Teertha Deb, 40227747"
date: "`r Sys.Date()`"
output: pdf_document
---

# Problem 3:

The goal of this problem is to simulate a random walk of an agent called Ada (in honor of Ada Lovelace) over an infinite two-dimensional grid, i.e. the set of all pairs $(i, j)$, where $i, j$ are integers.

The random walk is defined as follows: - The random walk is composed of a sequence of positions $A_0, A_1, A_2, \ldots$, where each $A_k$ is a 2D point with integer coordinates. - At time $t = 0$, Ada is in position $A_0 = (0,0)$. - Assume Ada to be in position $A_t$ at time $t$. At time $t + 1$, she will move up, down, left, or right with equal probability. For example, if $A_t = (3,-1)$, then $A_{t+1}$ can be either $(4, -1)$, $(3,0)$, $(2, -1)$, or $(3,-2)$ with equal probability. - Ada always moves. ($A_t \neq A_{t+1}$ for all $t$) - The random walk stops when Ada is back in position $(0,0)$ or if she has already done more than 100 steps. In that case, her final position will be $A_{100}$, which might or might not be $(0,0)$.

## Question 1:

Write a function with header `.AdaWalk <- function()`. The function should return the trajectory of Ada's random walk. The positions $A_t$ should be stored as columns of a matrix with two rows.

### Answer:

```{r}
AdaWalk <- function() {
  # Initialize Ada's starting position
  current_position <- c(0, 0)
  
  # Initialize an empty matrix to store Ada's trajectory
  trajectory <- matrix(nrow = 2, ncol = 1)
  trajectory[, 1] <- current_position
  
  # Set maximum number of steps
  max_steps <- 100
  
  # Define possible movements
  movements <- matrix(c(1, -1, 0, 0, 0, 0, -1, 1), ncol = 2, byrow = TRUE)
  
  # Perform random walk until Ada returns to (0, 0) or maximum steps reached
  for (step in 1:max_steps) {
    # Generate random movement
    move <- sample(movements, 1)
    
    # Update Ada's position
    current_position <- current_position + move
    
    # Append new position to trajectory matrix
    trajectory <- cbind(trajectory, current_position)
    
    # Check if Ada has returned to (0, 0)
    if (all(current_position == c(0, 0))) {
      break
    }
  }
  
  return(trajectory)
}

# Call the AdaWalk function to get Ada's trajectory
ada_trajectory <- AdaWalk()
```

## Question 2:

Plot 4 examples of random walks generated by your code, choosing an appropriate visualization strategy.

### Answer:

```{r}
# Function to generate and plot random walks with lines connecting the points
plot_random_walks <- function(num_walks = 4) {
  # Set up plot layout
  par(mfrow = c(2, 2))
  
  # Generate and plot random walks
  for (i in 1:num_walks) {
    # Generate random walk trajectory
    ada_trajectory <- AdaWalk()
    
    # Plot trajectory with lines connecting points
    plot(ada_trajectory[1, ], ada_trajectory[2, ], 
         type = "l", xlab = "X", ylab = "Y", 
         main = paste("Random Walk", i), col = i)
    
    # Add scatter plot points for better visualization
    points(ada_trajectory[1, ], ada_trajectory[2, ], pch = 16, col = i)
  }
}

# Call the function to plot random walks
plot_random_walks()
```

## Question 3:

Estimate the probability that Ada comes back to the origin (0,0) in at most 100 steps. Use a Monte Carlo simulation with at least 100 repeated experiments (or more, if your computer can).

### Answer:

```{r}
# Function to perform Monte Carlo simulation
monte_carlo_simulation <- function(num_experiments = 100) {
  # Initialize counter for number of times Ada returns to the origin
  num_returns_to_origin <- 0
  
  # Loop for each experiment
  for (i in 1:num_experiments) {
    # Simulate Ada's random walk
    ada_trajectory <- AdaWalk()
    
    # Check if Ada returns to the origin within 100 steps
    if (any(ada_trajectory[, ] == c(0, 0))) {
      num_returns_to_origin <- num_returns_to_origin + 1
    }
  }
  
  # Calculate the probability
  probability <- num_returns_to_origin / num_experiments
  
  return(probability)
}

# Function to print Ada's trajectory
print_trajectory <- function(ada_trajectory) {
  plot(ada_trajectory[1, ], ada_trajectory[2, ], type = "l", 
       xlab = "X", ylab = "Y", main = "Ada's Random Walk")
}

# Perform and print the Monte Carlo simulation multiple times
num_simulations <- 10
for (i in 1:num_simulations) {
  ada_trajectory <- AdaWalk()
  print_trajectory(ada_trajectory)
}


```

## Question 4:

Estimate the average number of steps needed by Ada to return to the origin, conditional on the event that she is able to do so in at most 100 steps. Use again at least 100 repetitions of the random walk.

### Answer:

```{r}
# Function to perform Monte Carlo simulation for average steps
monte_carlo_average_steps <- function(num_repetitions = 100, max_steps = 100) {
  # Initialize vector to store the number of steps for each repetition
  steps_needed <- numeric(num_repetitions)
  
  # Loop for each repetition
  for (i in 1:num_repetitions) {
    # Initialize counter for number of steps
    num_steps <- 0
    
    # Simulate Ada's random walk
    ada_trajectory <- AdaWalk()
    
    # Check if Ada returns to the origin within max_steps
    while (num_steps < max_steps && any(ada_trajectory[, ] != c(0, 0))) {
      # Increment the number of steps
      num_steps <- num_steps + 1
      
      # Simulate one step of Ada's random walk
      ada_trajectory <- cbind(ada_trajectory, AdaWalk())
    }
    
    # Store the number of steps needed for this repetition
    steps_needed[i] <- num_steps
  }
  
  # Filter out the cases where Ada did not return to the origin
  steps_needed <- steps_needed[steps_needed < max_steps]
  
  # Calculate the average number of steps
  average_steps <- mean(steps_needed)
  
  return(average_steps)
}

# Perform the Monte Carlo simulation and calculate the average steps
estimated_average_steps <- monte_carlo_average_steps(num_repetitions = 100)

# Print the estimated average number of steps
print(estimated_average_steps)

```
